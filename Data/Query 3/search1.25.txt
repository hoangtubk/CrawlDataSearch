URL | http://tailieu.tv/tai-lieu/giai-thuat-di-truyen-song-song-va-ung-dung-giai-bai-toan-max-sat-10882/
Title | Giải thuật di truyền song song và ứng dụng giải bài toán max- Sat
Content |TRƯỜNG ĐẠI HỌC SƯ PHẠM HÀ NỘI KHOA CÔNG NGHỆ THÔNG TIN BÁO CÁO KHOA HỌC ĐỀ TÀI: GIẢI THUẬT DI TRUYỀN SONG SONG VÀ ỨNG DỤNG GIẢI BÀI TOÁN MAX- SAT Giảng viên hướng dẫn : Thầy Đỗ Trung Kiên Sinh viên thực hiện : Nguyễn Thị Lụa – K54C Đỗ Văn Quang – K55B Trần Đăng Doanh- K55B MỤC LỤC LỜI MỞ ĐẦU……………………………………………………………………2 Chương I : Tổng quan ….………………………………………………………..3 Tổng quan thuật toán di truyền ………………………………………………4 Khái niệm……………………………………………………………………..4 Cấu trúc của thuật toán di truyền …………………………………………….7 Ví dụ minh họa………………………………………………………………12 2.1 Bài toán Max-sat …………………………………………………………….12 2.2 Giải thuật di truyền giải quyêt bài toán Max-sat……………………………..14 Chương II : Xây dựng thuật toán di truyền ……………………………………...14 Khung thiết kế thuật toán di truyền ………………………………………...15 Lớp provides – lớp cung cấp………………………………………………..15 Lớp Requide – Lớp yêu cầu ………………………………………………..16 Khung thuật toán tuần tự …………………………………………………….20 Khung thuật toán song song ………………………………………………….22 3.1 Lựa chọn phần cứng ………………………………………………………….22 3.2 Lựa chọn phần mềm………………………………………………………….22 Chương III : sử dụng khung thuật toán di truyền giải quyết bài toán Maxsat……26 1. cài đặt bài toán Max-sat………………………………………………………...26 1.1 file cấu hình .cfg……………………………………………………………….26 1.2 file đầu vào .dat ……………………………………………………………….26 2. Sử dụng khung thuật toán di truyền giải bài toán Max-sat……………………..27 Chương III : Kết quả thực nghiệm ………………………………………………..28 1. kết quả tuần tự …………………………………………………………………..28 2.Kết quả song song……………………………………………………………….28 LỜI MỞ ĐẦU Với khả năng hiện nay, máy tính đã giúp giải được rất nhiều bài toán khó mà trước đây thường bó tay. Mặc dù vậy vẫn có một số lớn các bài toán thú vị mà chưa có giải thuật hợp lý để giải chúng. Trong đó các bài toán tối ưu là nững bài toán thường gặp trong thực tiễn. Trong thực tiễn, có nhiều bài toán tối ưu quan trọng đòi hỏi những thuật toán có chất lượng cao. Ví dụ ta có thể dùng phương pháp mô phỏng luyện thép để giải quyết bài toán tìm đường đi ngắn nhất cho xe cứu hỏa hay bài toán người du lịch… Cũng có nhiều bài toán tối ưu tổ hợp (trong đó có nhiều bài toán được chúng minh là NP - đủ) có thể giải gần đúng trên máy tính hiện đại bằng kỹ thuật Monte - Carlo. Nói chung bài toán tối ưu có thể xem như bài toán tìm kiếm giải pháp tốt nhất trong không gian vô cùng lớn các giải pháp. Khi không gian tìm kiếm nhỏ, những phương pháp cổ điển như trên cũng đủ thích hợp, nhưng khi không gian tìm kiếm lớn phải dùng kỹ thuật trí tuệ nhân tạo đặc biệt. Thuật giải di truyền (GA) là một trong những kỹ thuật đó. CHƯƠNG I : TỔNG QUAN 1. Tổng quan thuật toán di truyền (Genetic Algorithm) 1.1 Khái niệm Thuật toán di truyền cổ điền là các kỹ thuật phỏng theo quá trình thích nghi tiến hóa của các quần thể sinh học dựa trên học thuyết Darwin. Tư tưởng của thuật toán di truyền là mô phỏng các hiện tượng tự nhiên: Kế thừa và đấu tranh sinh tồn để cái tiến lời giải và khảo sát không gian lời giải khái niệm kế thừa và đấu tranh sinh tồn được giải thích qua thí dụ về sự tiến hóa của một quần thể thỏ như sau: Có một quần thể thỏ, trong đó có một số con nhanh nhẹn và thông minh hơn những con khác. Những chú thỏ nhanh nhẹn và thông minh có xác suất bị chồn cáo ăn thịt nhỏ hơn, do đó cũng tồn tại dể làm những gì tốt nhất có thể : Tạo thêm nhiều thỏ tốt. Dĩ nhiên, một số thỏ chậm chạp đần độn cũng sống sót vì may mắn. Quần thể những chú thỏ còn sống sót sẽ bắt đầu sinh sản. Việc sinh sản này sẽ tạo ra một hỗn hợp tốt về "nguyên liệu di truyền thỏ". Một số thỏ chậm chạp có con với những con thỏ nhanh, một số nhanh nhẹn có con với thỏ nhanh nhẹn, một số thông minh với thỏ đần độn… Và trên tất cả thiên nhiên lại ném vào một con thỏ "hoang dã" bằng cách làm đột biến nguyên liệu di truyền thỏ. Những chú thỏ con do kết quả này sẽ nhanh hơn và thông minh hơn những con thỏ trong quần thể gốc vì có nhiều bố mẹ nhanh nhẹn và thông minh hơn đã thoát chết khỏi chồn cáo. Khi tìm kiếm lời giải tối ưu , thuật toán di truyền cũng thực hiện các bước tương ứng với câu chuyện đấu tranh sinh tồn của loài thỏ. Thuật toán di truyền sử dụng các thuật ngữ vay mượn của di truyền học. Ta có thể nói về các cá thể (hay kiểu gen, cấu trúc) trong một quần thể, những cá thể này cũng còn được gọi là chuỗi hay các nhiễm sắc thể. Mỗi kiểu gen (ta gọi là một nhiễm sắc thể) sẽ biểu diễn một lời giải của bài toán đang giải (ý tưởng của một nhiễm sắc thể cụ thể được người sử dụng xác định trước), một tiến trình tiến hóa được thực hiện trên một quần thể các nhiễm sắc thể tương ứng với một quá trình tìm kiếm lời giải trong không gian lời giải. Tìm kiếm đó cần cân đối hai mục tiêu: Khai thác những lời giải tốt nhất và khảo sát không gian tìm kiếm. Leo đồi là một ví dụ về chiến lược cho phép khai thác và cải thiện lời giải tốt nhất hiện hành nhưng leo đồi lại bỏ qua việc khảo sát không gian tìm kiếm. Ngược lại, tìm kiếm ngẫu nhiên là một ví dụ điển hình của chiến lược khảo sát không gian tìm kiếm mà không chú ý đến việc khai thác những vùng đầy hứa hẹn của không gian. Thuật toán di truyền (GA) là phương pháp tìm kiếm (độc lập miền) tạo được sự cân đối đáng kể giữa việc khai thác và khảo sát không gian tìm kiếm. Thực ra, GA thuộc lớp các thuật giải xuất sắc, nhưng lại rất khác những thuật giải ngẫu nhiên vì chúng kết hợp các phần tử tìm kiếm trực tiếp và ngẫu nhiên. Khác biệt quan trọng giữa tìm kiếm của GA và các phương pháp tìm kiếm khác là GA duy trì và xử lý một tập các lời giải (ta gọi là một quần thể) Theo đề xuất của giáo sư John Holland, một vấn đề bài toán đặt ra sẽ được mã hóa thành các chuỗi với chiều dài bit cố định. Nói một cách chính xác là các thông số của bài toán sẽ được chuyển đổi và biểu diễn lại dưới dạng các chuỗi nhị phân. Các thông số này có thể là các biến của một hàm hoặc hệ số của một biểu thức toán học. Người ta gọi các chuỗi bít này là mã genome ứng với mỗi cá thể, các genome đều có cùng chiều dài. Nói ngắn gọn, một lời giải sẽ được biểu diễn bằng một chuỗi bít, cũng như mỗi cá thể đều được quy định bằng gen của cá thể đó vậy. Như vậy, đối với thuật giải di truyền, một cá thể chỉ có một gen duy nhất và mọt gen cũng chỉ phục vụ cho một cá thể duy nhât. Do đó, gen chính là cá thể và cá thể chính là gen. Ban đầu, ta sẽ phát sinh một số lượng lớn, giới hạn các cá thể có gen ngẫu nhiên - nghĩa là phát sinh một tập hợp các chuỗi bit ngẫu nhiên. Tập các cá thể này được gọi là quần thể ban đầu (initial population). Sau đó, dựa trên một hàm nào đó, ta sẽ xác định được một giá trị có độ thích nghi - Fitness. Giá trị này, để đơn giản cho đơn giản chính là độ "tốt" của lời giải hay đọ cao trong tìm kiếm theo kiểu leo đồi. Vì phát sinh ngẫu nhiên nên độ "tốt" của lời giải hay tính thích nghi của cá thể trong quần thể ban đầu là không xác định. Để cải thiện tính thích nghi của quần thể người ta tìm cách tạo ra quần thể mới. Có hai cách thao tác thực hiện trên thế hệ hiện tại để tạo ra một thế hệ khác với độ thích nghi tốt hơn. Thao tác đầu tiên là sao chép nguyên mẫu một nhóm các cá thể tốt từ thế hệ trước rồi đưa sang thế hệ sau (selection). Thao tác này đảm bảo độ thích nghi của thế hệ sau luôn được giữ ở một mức độ hợp lý. Các cá thể được chọn thông thường là các cá thể có độ thích nghi cao nhất. Thao tác thứ hai là tạo ra cá thể mới bằng cách thực hiện các thao tác sinh sản trên một số cá thể được chọn từ thế hệ trước, thông thường cũng là những cá thể có độ thích cao. Có hai loại thao tác sinh sản: một là thao tác lai tạo (crossover), hai là đột biến (mutalion). Trong thao tác lai tạo, từ gen của hai cá thể được chọn trong thế hệ trước sẽ được phối hợp với nhau (theo một quy tác nào đó) để tạo thành hai gen mới. Thao tác chọn lọc và lai tạo giúp tạo ra thế hệ sau. Tuy nhiên, nhiều khi do thế hệ khởi tạo ban đầu có đặc tính chưa phong phú và chưa phù hợp nên các cá thể không rải đều được không gian của bài toán (tương tự như trường hợp leo đồi, các người leo đồi tập trung dồn vào một góc trên vùng đất). Từ đó, khó có thể tìm ra lời giải tối ưu cho bài toán. Thao tác đột biến sẽ giúp giải quyết được vấn đề này. Đó là sự biến đổi ngẫu nhiên một hoặc nhiều thành phần gen của một cá thể ở thế hệ trước tạo ra một cá thể hoàn toàn mới ở thế hệ sau. Nhưng thao tác này chỉ được phép sảy ra với tần xuất rất thấp (thường dưới 0.01), vì thao tác này có thể gây xáo trộn và làm mất đi những cá thể chọn lọc và lai tạo có tính thích nghi cao, dẫn đến thuật toán không còn hiệu quả. Thế hệ mới được tạo ra lại được xử lý như thế hệ trước cho đến khi có một cá thể đạt được giải pháp mong muốn hoặc đạt đến thời gian giới hạn. 1.2 Cấu trúc của giải thuật di truyền như sau: 1. t = 0 2. initialize P(t) 3. evaluate structures in P(t) 4. while not end do 5. t = t + 1 6. select C(t) from P(t - 1) 7. recombine structures in C(t) forming C'(t) 8. mutate structures in C' (t) forming C'' (t) 9. evaluate structures in C''(t) 10. replace P(t) from C''(t) and/or P (t - 1) Khởi tạo quần thể (initialize): Quần thể đầu tiên được khởi tạo một cách ngẫu nhiên từ tập hợp những cá thể riêng lẻ. Kích cỡ của quần thể đầu tiên phụ thuộc vào yếu tố tự nhiên của bài toán, nhưng nhìn chung thì một bài toán có đến hàng trăm hay hàng nghìn giải pháp hợp lý. Tập hợp những giải pháp hợp lý cho vấn đề được gọi là không gian tìm kiếm (search space). Trước một bài toán áp dụng thuật toán di truyền, ta cần phải xác định rõ nhiễm sắc thể và cá thể cho vấn đề, và thông thường đó sẽ là kết quả cuối cùng. Việc phân tích sẽ dựa trên kết quả cơ bản tốt nhất. Hàm định nghĩa độ thích nghi (evaluate): Các quá trình tiến hóa diễn ra trong vòng lặp While, tại thế hệ thứ t, thuật toán di truyền duy trì một tập lời giải P(t) = {xt1, xt2, ,…, xtn }. Mỗi lời giải xti được đánh giá "độ thích nghi ", hay độ "tốt" của lời giải. Phép chọn lọc (select): Phép chọn là quá trình loại bỏ các cá thể xấu trong quần thể để chỉ dữ lại trong quần thể các cá thể tốt. Phép chọn được mô phỏng: Sắp xếp quần thể theo thứ tự độ thích nghi giảm dần. Loại bỏ các cá thể cuối dãy để chỉ giữ lại n cá thể tốt nhất. Giả sử ở đây quần thể có kích thước cố định n. Có nhiều phương pháp chọn lọc Nhiễm sắc thể: Chọn lọc Roulette (Roulett Wheel Selection). Chọn lọc xếp hạng (Rank Selection). Chọn lọc cạnh tranh (Tournament Selection) Quá trình sinh sản: Có hai loại thao tác sinh sản Phép lai tạo (Crossover): là quá trình hình thành nhiễm sắc thể mới trên cơ sở nhiễm sắc thể cha mẹ bằng cách ghép một hay nhiều đoạn gen của hai hay nhiều nhiễm sắc thể cha mẹ với nhau. Có những phương pháp lai ghép sau: Lai ghép ánh xạ từng phần (PMX Partial Mapped Crossover). Lai ghép có trật tự (OX order Crossover). Lai ghép dựa trên vị trí (Position Based Crossover). Lai ghép dựa trên thứ tự (Order Base Crossover). Lai ghép có chu trình (CX cycle Crossover). Lai ghép thứ tự tuyến tính (LOX Linear order Crossover). Phép lai tạo xảy ra với xác suất pc, được mô phỏng như sau: Chọn ngẫu nhiên một hay nhiều cá thể bất kỳ trong quần thể. Giả sử các nhiễm sắc thể của cha mẹ đều có m gen. Tạo một số ngẫu nhiên trong khoảng từ 1 đến m - 1 (được gọi là điểm lai). Điểm lai chia các chuỗi cha mẹ có độ dài m thành hai nhóm chuỗi con với độ dài m1, m2 hai chuỗi nhiễm sắc thể mới là m11 + m12 và m21 + m22 Đưa hai cá thể mới vào quần thể để tham gia các quá trình tiến hóa tiếp theo. Ví dụ : Hai nhiễm sắc thể cha mẹ : Parent 1: 1 0 1 0 1 1 1 0 0 1 Parent 2: 0 1 1 1 0 0 1 1 1 0 Thì việc trao đổi chéo các nhiễm sắc thể sau gen thứ năm sẽ tạo ra hai con: Child 1: 1 0 1 0 1 0 1 1 1 0 Child 2: 0 1 1 1 0 1 1 0 0 1 Phép đột biến (mutalion): Phép đột biến là hiện tượng cá thể con mang một (hoặc một số) tính trạng có trong mã di truyền của cha mẹ, tức là sự sửa đổi một hoặc một vài gen của một nhiễm sắc thể chọn bằng cách thay đổi ngẫu nhiên với xác suất là tỷ lệ đột biến. Không ai có thể đánh giá được phương pháp đột biến nào tốt hơn, do đó có một vài phương pháp đơn giản, cũng có vài trường hợp khá phức tạp. Người ta thường chọn một trong những phương pháp sau : Đột biến đảo ngược (Inversion Mutation). Đột biến chèn (Insertion Mutation) Đột biến thay thế (Displacement Mutation). Đột biến tương hỗ (Reciprocal Exchange). Đột biến chuyển dịch (Shift Mutation). Phép đột biến xảy ra với xác suất pm nhỏ hơn rất nhiều so với xác suất lai pc. Phép đột biến có thể được mô phỏng: Chọn ngẫu nhiên một cá thể bất kỳ cha mẹ trong quần thể. Tạo một số ngẫu nhiên k trong khoảng từ 1 đến m với 1≤ k ≤ m. Thay đổi gen thứ k và trả cá thể này về quần thể để tham gia vào quá trình tiến hóa tiếp theo. NST1 0 1 1 1 1 0 1 1 1 0 NST1 0 1 1 1 0 0 1 1 1 0 Một thuật giải di truyền, giải một bài toán được cho phải có năm thành phần: Một cấu trúc dữ liệu biểu diễn không gian lời giải của bài toán. Phương pháp khởi tạo quần thể ban đầu P(0). Hàm định nghĩa độ thích nghi evaluate đóng vai trò môi trường. Các phép toán di truyền như đã mô phỏng trên. Và các tham số thuật toán di truyền sử dụng (kích thước, quần thể, xác suất lai, đột biến…) Điều kiện kết thúc Thoát ra quá trình tiến hóa quần thể, dựa vào bài toán mà có các cách kết thúc vấn đề khác nhau, một khi đã đạt đến mức yêu cầu. Một vài trường hợp thông thường như sau: Kết thúc theo kết quả: một khi đạt đến mức giá trị yêu cầu thì chấm dứt ngay quá trình thực hiện. Kết thúc dựa vào số thế hệ: chọn số thế hệ, quá trình sẽ dừng lại đúng ngay số thế hệ đã qui định trước, không cần biết kết quả như thế nào. Tính theo thời gian: Không cần biết đã bao nhiêu thế hệ hay kết quả thế nào, chỉ cần dựa vào số giờ qui định mà kết thúc. Tổ hợp: dung nhiều phương án khác nhau cho vấn đề, chẳng hạn như: chạy theo số thế hệ xong sau đó đánh giá cho chạy theo kết quả, hoặc ngược lại. 2. Một số ví dụ minh họa. 2.1 Bài toán Max-sat. Vấn đề bài toán SAT (SATisfiability) là vấn đề có tính ứng dụng rộng rãi cả trong lý thuyết độ phức tạp, trong Trí tuệ nhân tạo hay những lĩnh vực thực tế khác… Mà cần đưa ra những giải pháp tốt để giải quyết. Bài toán SAT: Cho tập m mệnh đề C= {C1, C2, C3, …,Cm} bao gồm n giá trị biến x1 x2, …, xn. Bài toán SAT giải quyết vấn đề có tồn tại hay không? Sự phân bố trên các biến sao cho các mệnh đề thỏa mãn đồng thời. Bài toán Max-Sat (Maximum Satisfiability) là bài toán tìm sự phân bố trên các biến sao cho các mệnh đề thỏa mãn là lớn nhất. Vấn đề giải quyết cả hai bài toán SAT và Maxsat là thuộc bài toán NP- khó. Có rất nhiều giải thuật thuật được đề xuất và đã đạt được những tiến bộ quan trọng. Những giải thuật này được chia thành hai lớp: Giải thuật đầy đủ (chính xác) và giải thuật chưa đầy đủ. Thuật giải đầy đủ:Giải thuật được coi là tốt dựa trên thủ tục DPLP. SAT2 là ví dụ khá nổi tiếng về giải thuật đủ. Giải thuật Nhánh cận và kết nối dựa vào thủ tụ DPLP là một trong những giải thuật chính xác và mạnh nhất để giải quyết bài toán Max-Sat. Giải thuật BnB có thể được vận dụng với mức độ khó vừa phải, được định nghĩa bởi tỉ số mệnh đề trên số biến của bài toán Max-Sat. Giải thuật chưa đầy đủ: Chủ yếu dựa vào tìm kiếm cục bộ và giải thuật tiến hóa. Tìm kiếm Tabu, mô phỏng luyện thép, giải thuật di truyền, GRASP, đó là những ví dụ về giải thuật chưa đầy đủ để giải quyết bài toán Max-Sat. Tìm kiếm dựa vào heuristics là phương pháp giải quyết tốt để tìm kiếm giải pháp tương đối cho những bài toán không biết được và không thỏa mãn lời giải. Nói chung, phương pháp đầy đủ đảm bảo được một lời giải tối ưu, nhưng thời gian thực thi của bài toán thì tỉ lệ thuận với kích thước bài toán. Vì vậy chỉ có những bài toan nhỏ thật sự có thể giải quyết đươc. Để giải quyết những bài toán lớn, chỉ có khả năng giải quyết bằng cách sử dụng tìm kiếm heuristics tìm kiếm một giải pháp tương đối tối ưu cho các bài toán lớn trong thời gian giới hạn, nhưng khả năng tối ưu thì không được đảm bảo. Thực tế thì đó là những sự cố gắng khác nhau để kết hợp những giải pháp chính xác và tìm kiếm heuristics. Mục đích tìm giải pháp tối ưu cho bài toán Max-Sat tương đối khó khăn chúng ta đề xuất giải pháp lai ghép gồm có Thuật giải di truyền là thuật giải chưa đầy đủ kết hợp với chiến lược đầy đủ của đơn vị nhân bản. 2.2 Giải thuật di truyền giải quyết bài toán Max-Sat: Biểu diễn cá thể: Một cá thể được biểu diễn bới chuỗi X (n vecto) mỗi thành phần Xi nhận giá trị 0 (False) hoặc 1 (True). Lai ghép: là phép toán mục đích xây dựng một quần thể mới (quần thể con) từ quần thể ban đầu. Đột biến: là phép toán dùng phát sinh cá thể mới . CHƯƠNG II : XÂY DỰNG KHUNG THUẬT TOÁN DI TRUYỀN Để giải quyết các bài toán với độ phức tạp rất lớn hoặc những bài toán có NP-khó thì một giải pháp là sử dụng các thuật toán chẳng hạn như thuật toán di truyền. Xây dựng khung chương trình (Skeletons) cần thiết cho những người muốn áp dụng các thuật toán nổi tiếng để giải bài toán khó, khi giải quyết những bài toán tương đối giống nhau cùng sử dụng một tư tưởng của của thuật giải, sử dụng các hàm và thư viện giống nhau, việc viết đi viết lại những hàm và thư viện này khiến mất thời gian và công sức. Xây dựng khung chương trình nhằm giảm thiểu quá trình code cho người sau, cho những người sau thử nghiệm bài toán lập trình song song để hiểu bài toán mà chưa cần hiểu sâu về code và quá trình phát triển.. 1. Thiết kế khung thuật toán di truyền. Khung thuật toán di truyền bao gồm hai lớp chính là: lớp Provides và Requies 1.1 Lớp Provides (lớp cung cấpi) làm nhiệm vụ thi hành bên trong bộ khung của bài toán, nó tạo ra nhiều phương án cho bài toán. Hàm Solver: Hiển thị trạng thái, xác suất, xác suất đột biến và chọn ra cha mẹ và con cái. Solver gồm một số hàm: Class Solver { Run() // Thực thi thuật toán StartUp() // Thiết lập các thông số. DoStep() // Thực hiện theo khung thuật toán newGA, } Hàm Solver_Sqe: Giải quyết bài toán bằng phương pháp tuần tự chạy trên một máy, đầu vào là bài toán và các tham số cài đặt. Hàm Solver_Lan: Giải quyết bài toán trên môi trường song song chạy kết hợp trên nhiều máy. Bao gồm khởi tạo MPI, thiết lập số hiệu của các máy, hàm in Solver_lan::pid() cont trả về số hiệu của mỗi máy từ đó có thể xác định được máy khách, máy chủ. Lớp Selection: Hàm lựa chọn những phần tử tốt nhất. Lớp Requied (lớp yêu cầu) Các lớp đòi hỏi được sử dụng để lưu trữ dữ liệu cơ bản của thuật toán : bài toán, trạng thái không gian tìm kiếm và vào/ra. Cụ thể bao gồm các lớp. Bài toán Problem: Định nghĩa bài toán cần giải quyết bao gồm một số hàm: Khai báo lớp Problem cho bài toán Maxsat. Class Problem { Public: int numvar() const; // Số biến đưa vào của bài toán int numclause() const; // Số mệnh đề của bài toán int lenclause() const; // Chiều dài mệnh đề private: int _numvar; int _numclause; int _lenclause; int ** _clauses; } Khai báo hàm trong Problem. istream& operator>> (istream& is, Problem& pbm){}: Nhập vào kích thước, số mệnh đề và chiều dài mệnh đề. Problem& Problem::operator= (const Problem& pbm{}: Tạo ra mảng một chiều _clauses gồm số mệnh đề, số phần từ à tạo ra mảng 2 chiều kích thước số mệnh đề, độ dài mệnh đề. Lưu các phần tử mệnh đề vào mảng. Tạo ra biến _dimension. Truyền giá trị số mệnh đề trong pbm.numlause() của lớp Pro vào _numclause trong mảng clause. Direction Problem::direction() const{}: Trả ra kích thước mệnh đề lớn nhất. int Problem::dimension() const{}: Trả ra kích thước mệnh đề. int Problem::numclause() const : trả ra số mệnh đề. int Problem::lenclause() const : trả ra độ dài mệnh đề int *Problem::clause(const int i) const:trả ra giá trị của mệnh đề thứ i Lớp Solution :định nghĩa một giải pháp có khả thi hay không Khai báo lớp Sulutioncho bài toán Maxsat: Class Solution { friend ostream& operator<< (ostream& os, const Solution& sol); // đưa ra các thông số của một lời giải friend istream& operator>> (istream& is, Solution& sol); // nhận vào các thông số của một lời giải …. void initialize(); // Hàm khởi tạo bộ giá trị ngẫu nhiên cho các phần tử trong lời giải double fitness (); // Hàm tính độ thích nghi làm cơ sở đánh giá lời giải. Một số hàm trong lớp Solution: Solution& Solution::operator= (const Solution &sol): Gán các giá trị trong các phương thức của lớp solution cho các biến. bool Solution::operator== (const Solution& sol) const: Lời giải bài toán xác định giá trị của mệnh đề là đúng hay sai, và trả ra giá trị cho mệnh đề đúng. double Solution::fitness(): Hàm đánh giá lời giải bài toán. void Solution::to_Solution(char *_string_) : duyệt từng phần tử của mệnh đề. void Solution::add(unsigned long element) :Phương thức thêm vào một lời giải phù hợp. void Solution::initialize_feasibles(Feasibles &_feasibles): khởi tạo giá trị ban đầu cho lời giải khả thi. Nếu (_freedomV[i] > 0) thì thêm giá trị đó vào danh sách lời giải khả thi. void Solution::update(Feasibles &f,unsigned long &selection) : cập nhật lời giải khả thi vào trong danh sách lời giải khả thi Lớp kiểm tra điều kiện dừng (StopCondition). Để xác định điều kiện dừng của bài toán, trong từng bài toán thì điều kiện dừng sẽ khác nhau, thường căn cứ vào một hoặc một vài tham số như số thế hệ, thời gian chạy, các điều kiện đặc thù của bài toán. Lớp chéo hóa Crossover. requires class Crossover: public Intra_Operator { public: Crossover(); virtual ~Crossover(); friend ostream& operator << (ostream& os, const Crossover& cross); void cross(Solution &sol1,Solution &sol2) const; virtual void execute(Rarray& sols) const; virtual void setup(char line[MAX_BUFFER]); virtual void RefreshState(const StateCenter& _sc) const; virtual void UpdateFromState(const StateCenter& _sc); }; Lớp đột biến (Mutation) requires class Mutation: public Intra_Operator { public: Mutation(); virtual ~Mutation(); friend ostream& operator<< (ostream& os, const Mutation& mutation); void mutate(Solution& sol) const; //Hiển thị đột biến qua tất cả các giải pháp trong mảng Sols virtual void execute(Rarray& sols) const; virtual void setup(char line[MAX_BUFFER]); virtual void RefreshState(const StateCenter& _sc) const; virtual void UpdateFromState(const StateCenter& _sc); }; Khung thuật toán tuần tự. Sử dụng khung thuật toán di truyền cho bài toán (newGA) đầu vào đưa vào gồm hai file cấu hình. Gọi tới hàm Problem: Hiển thị màn hình thông số đưa vào. Hàm void Solver_sqe :: DoStep() Class Solver_sqe:: DoStep(){ current_iteration(current_iteration()+1); current_population.evolution(); current_evaluations(current_population.evaluations()); // Lấy giá trị phù hợp để thực hiện trong quần thể đang thực thi. best_cost=current_population.best_cost(); best_solution=current_population.best_solution(); worst_cost=current_population.worst_cost(); average_cost=current_population.average_cost(); standard_deviation=current_population.standard_deviation(); time_spent_in_trial = _used_time(start_trial); total_time_spent = start_global + time_spent_in_trial; // lấy lại trạng thái với nhứng giá trị này RefreshState(); RefreshCfgState(); if( (current_iteration() % params.refresh_global_state()) == 0) UpdateFromCfgState(); _stat.update(*this); _userstat.update(*this); if (display_state()) show_state(); Hàm mainseq () Void Solver_Seq :: solver(); Sử dụng khung newGA; Mở file f1 là “newGA.cfg” để đọc vào cấu hình Đọc file f1>>cfg; Mở file f2 để đọc “Problem.dat” Đọc file f2>>pbm Thực hiện hàm SetUpParams Solver.run(); // thực hiện hàm run Nếu là máy chủ (pid()= =0) thì { Gọi đến hàm hiện trạng thái (show_state()); Đưa ra giải pháp tốt nhất; Đưa ta Độ thích nghi tốt nhất; } Khung thuật toán song song. 3.1 Lựa chọn mô hình phần cứng: Có hai mô hình đó là: mô hình phần cứng phân tán và mô hình phần cứng dùng chung. + Mô hình phần cứng dung chung: Ưu điểm: tốc độ nhanh Nhược điểm: giá thành cao. + Mô hình phần cứng phân tán: Ưu điểm: dễ cài đặt. Nhược điểm: tốc độ chậm. Vì những lý do trên ta sử dụng mô hình phần cứng phân tán để việc nói chuyện giữa các máy tính được dễ dàng. Trong mô hình này ta sử dụng các thư viện MPI và thư viện NetStream nhằm tạo ra sự thân thiện với người sử dụng. 3.2 Lựa chọn mô hình phần mềm: Có ba mô hình phần mềm: - Mô hình chủ - khách (Master_slave):ở đây một bộ vi xử lý đơn duy trì việc điều khiển qua các vùng chọn và sử dụng bộ vi xử lý khác cho việc xử lý chéo, biến đổi và giá trị đơn lẻ. tuy nhiên giải thuật chỉ hữu ích cho một số lượng nhỏ bộ vi xử lý và một số lượng lớn thời gian, mặt khác một giao tiếp tốt làm tăng khả năng của xử lý song song. - Mô hình đảo (Island model): Trong mô hình này mọi bộ vi xử lý chạy giải thuật tiến hóa một cách độc lập, sử dụng các quần thể phụ riêng biệt các bộ vi xử lý hợp tác với nhau bằng việc thay đổi vị trí một cách đều đặn. Mô hình đảo đặc biệt thích hợp cho các nhóm máy tính khi giao tiếp bị hạn chế. - Mô hình khuếch tán (Diffusion model): mỗi cá nhân là một không gian được sắp xếp và kết hợp với cá nhân khác từ một mạng nội bộ bên cạnh. Khi xử lý song song có rất nhiều bộ vi xử lý giao tiếp với nhau (như là những cá nhân giao tiếp với hàng xóm trong mọi tương tác), nhưng giao tiếp chỉ trong nội bộ. Vì vậy mô hình này chỉ phù hợp với hệ thống máy tính song song lớn với mạng nội bộ tốc độ cao. Do đó ta sẽ lựa chọn mô hình phần mềm là mô hình đảo (Island model). Hàm void Solver_lan:: DoStep() Voi Solver_lan::DoStep() { current_iteration(current_iteration()+1); current_population.evolution(); current_evaluations(current_population.evaluations()); _netstream << set_source(0); int pending; _netstream._probe(regular, pending); if(pending) final_phase = true; current_population.interchange(current_iteration(),_netstream); best_cost=current_population.best_cost(); best_solution=current_population.best_solution(); worst_cost=current_population.worst_cost(); average_cost=current_population.average_cost(); standard_deviation=current_population.standard_deviation(); time_spent_in_trial = _used_time(start_trial); total_time_spent = start_global + time_spent_in_trial; // refresh state with these values RefreshState(); RefreshCfgState(); // in this iteration i have to send data about my local state to the global state if ((int)current_iteration() % params.refresh_global_state() ==0) { send_local_state_to(mypid); UpdateFromCfgState(); } _stat.update(*this); _userstat.update(*this); // if (display_state()) show_state(); } Hàm void main_lan(); Sử dụng khung newGA; Mở file f1 là “newGA.cfg” để đọc vào cấu hình Đọc file f1>>cfg; Mở file f2 để đọc “Problem.dat” Đọc file f2>>pbm Thực hiện hàm SetUpParams Solver.run(); // thực hiện hàm run Nếu là máy chủ (pid()= =0) thì { Gọi đến hàm hiện trạng thái (show_state()); Đưa ra giải pháp tốt nhất; Đưa ta Độ thích nghi tốt nhất; } CHƯƠNG III. SỬ DỤNG KHUNG THUẬT TOÁN DI TRUYỀN GIẢI QUYẾT BÀI TOÁN MAXSAT. Cài đặt bài toán Maxsat: . file cấu hình .cfg. 5 // số bước chạy độc lập 200 // số cá thể phát sinh 50 //số cá thể 100 //kích thước quần thể con trong mỗi lần phát sinh 1 // nếu thay thế bố mẹ bằng con cái 1 // Hiển thị trạng thái ? Selections // lựa chọn để hiển thị 1 3 // lựa chọn bố mẹ 2 0 // lựa chọn con cái Intra-Operators // tính toán và hiển thị trong quần thể 0 0.6 // khả năng chéo hóa 1 1.0 0.01 // khả năng đột biến Inter-Operators // tính toán hiển thị quần thể này hay quần thể khác 0 25 5 1 3 1 5 // tính toán thành phần, tốc độ số cá thể, lựa chọn cá thể, lựa chọn cá thể LAN-configuration 10 // trả lại trạng thái toàn cục 0 // 0: running in asynchronized mode / 1: running in synchronized mode 1 File đầu vào của bài toán. File đầu vào là một mảng problem.dat Gồm số biến đưa vào, mệnh đề đưa vào. Sử dụng khung thuật toán newGA để giải quyết bài toán Maxsat. Sử dụng khung thuật toán di truyền để giải quyết bài toán MaxSat phải đắp thêm code vào 4 lớp đối với khung thuật toán. Bốn lớp đó là: Đối với từng Class cụ thể ta thêm như sau. Class problem và Solution nằm trong File newGA.hh để khai báo các thuộc tính và phương thức: Ở lớp Problem ta phải thêm đoạn code sau: istream& operator>> (istream& is, Problem& pbm)       {          int l,n;          is >> pbm._numvar >> pbm._numclause >> pbm._lenclause;          n = pbm._lenclause;          pbm._clauses = new int*[pbm._numclause];          // read clauses for (int i = 0; i < pbm._numclause; i++)          {              pbm._clauses[i] = new int[n];              for(int j = 0; j < n;j++)              {                  is >> l;                  pbm._clauses[i][j] = l;              }              is >> l;          } Trong hàm initialize trong lớp Solution thêm vào: void Solution::initialize()       {          for (int i=0;i<_pbm.numvar();i++)             _var[i]=rand_int(0,1);       } Trong hàm fitness trong hàm Solution thêm: double Solution::fitness ()       {          double fitness = 0.0;          int acum = 0;          for(int i = 0; i < _pbm.numclause(); i++)          {              int *rl = _pbm.clause(i);              acum = 0;              for(int j = 0; (j < _pbm.lenclause()) && (acum != 1);j++)              {                 if( ((rl[j] < 0) && (_var[(int)abs(rl[j])-1] == 0))                  || ((rl[j] > 0) && (_var[rl[j]-1] == 1)) )                      acum = 1;              }              fitness += acum;          } return fitness;       } CHƯƠNG IV: KẾT QUẢ THỰC NGHIỆM (Chương trình đã chạy nhưng chưa đủ máy để chạy song song nên thứ 6 em sẽ trình bày sau) Kết quả tuần tự Kết quả song song. 
boolean | true
